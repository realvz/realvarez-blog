<!DOCTYPE html><html domain=realvarez.com ga-id=G-B5XRB3YVTR lang=en><meta charset=utf-8><meta content="width=device-width,initial-scale=1" name=viewport><link href=/favicon.svg rel=icon type=image/svg+xml><meta content=#f9c412 name=theme-color><meta content="max-snippet:-1, max-image-preview: large, max-video-preview: -1" name=robots><title>How is eBPF efficient for observability</title><meta content="How is eBPF efficient for observability" property=og:title><meta content="A brief look into how eBPF works" name=description><meta content="A brief look into how eBPF works" property=og:description><meta content=summary_large_image name=twitter:card><meta content=@realz name=twitter:site><meta content=@realz name=twitter:creator><link href=https://blog.realvarez.com/posts/ebpf-speed-explained/ rel=canonical><meta content=no-referrer-when-downgrade name=referrer><link href=/feed/feed.xml rel=alternate type=application/atom+xml title="Re Alvarez Parmar's Blog"><link href=/ rel=preconnect crossorigin=""><link href=/fonts/Inter-3.19.var.woff2 rel=preload type=font/woff2 as=font crossorigin=""><script async defer src="/js/min.js?hash=8db32dcb3a"></script><script async defer src="/js/cached.js?hash=29681a444d"></script><script csp-hash="">if (/Mac OS X/.test(navigator.userAgent))document.documentElement.classList.add('apple')</script><style>:root{--primary: #f9c412;--primary-dark: #e7bf60;--main-width: calc(100vw - 3em)}main img{content-visibility:auto}article *{scroll-margin-top:50px}header nav{position:fixed;padding:.375em 1.5em;background:rgba(255,255,255,.9);font-weight:200;text-align:right}@media (min-width:37.5em){:root{--main-width: calc(37.5em - 3em)}}dialog,share-widget{position:fixed;opacity:.9}share-widget{right:20px;bottom:20px}share-widget div{width:30px;height:30px;background-image:url(/img/share.svg);background-repeat:no-repeat;background-position:center}.apple share-widget div{background-image:url(/img/share-apple.svg)}body,share-widget button{margin:0}share-widget button:active{transform:scale(1.2)}dialog{background-color:#8dff80;z-index:1000}header aside{font-style:italic}#nav{z-index:2;position:relative}#reading-progress,header nav{z-index:1;width:100vw;left:0;top:0}#reading-progress{background-color:var(--primary);position:absolute;bottom:0;transform:translate(-100vw,0);will-change:transform;pointer-events:none}#posts li{margin-bottom:.5em}@font-face{font-display:optional;font-family:"Inter UI";font-weight:100 900;font-style:oblique 0deg 10deg;src:url(/fonts/Inter-3.19.var.woff2) format("woff2")}html{line-height:1.15;-webkit-text-size-adjust:100%;font-family:Inter UI,sans-serif;--font-family: Inter UI, sans-serif}h1{font-size:3em;line-height:1.25;margin:.67em 0 .5em;font-size:2.074rem}button,hr{overflow:visible}hr{box-sizing:content-box;height:0;border-bottom:1px solid #eee}a{background-color:transparent;color:#f9c412;text-decoration:none;color:var(--primary)}strong{font-weight:700}code{overflow-x:auto;border-radius:.3em;color:#e2777a;padding:0 .3em;font-family:Consolas,Monaco,Andale Mono,Ubuntu Mono,monospace;font-size:90%;background:#2d2d2d}small{font-size:80%;color:#ccc}img{border-style:none;max-width:100%;height:auto;margin:0 auto}button{font-family:inherit;font-size:100%;line-height:1.15;text-transform:none}[type=button],button{-webkit-appearance:button}[type=button]::-moz-focus-inner,button::-moz-focus-inner{border-style:none;padding:0}[type=button]:-moz-focusring,button:-moz-focusring{outline:1px dotted ButtonText}[type=number]::-webkit-inner-spin-button,[type=number]::-webkit-outer-spin-button{height:auto}h2{font-size:2.5em;line-height:1.2;margin-bottom:.6em}h1,h2,h4{margin-bottom:1.36rem}h4{font-size:1.5em;margin-bottom:1em;line-height:1.5em;line-height:1.6rem;font-size:1.2rem}body,p,ul{font-size:1em}p,ul{margin-bottom:1.5em}h1,h2{line-height:2.4rem}h2{font-size:1.728rem}body,p,ul{font-size:1rem;line-height:1.6}p,ul{margin-bottom:1.36rem}@media (min-width:600px){h1{font-size:4.3978rem;line-height:4.4rem}h2{font-size:3.1097rem;line-height:3.52rem}h4{font-size:1.5554rem;line-height:1.76rem}body,p,ul{font-size:1.1rem;line-height:1.6}h1,h2,h4,p,ul{margin-bottom:1.496rem}}@media (min-width:1200px){h1{font-size:6.0756rem;line-height:6.72rem}h2{font-size:4.05rem;line-height:4.8rem}h4{font-size:1.8rem;line-height:1.92rem}body,p,ul{font-size:1.2rem;line-height:1.6}h1,h2,h4,p,ul{margin-bottom:1.632rem}}h1,h2,h4{font-family:var(--font-family)}h2,h4{font-style:italic}a:hover{text-decoration:underline}dt{font-weight:600;padding-top:.75em;padding-left:.75em}button{border-radius:.3em;max-width:100%;background:#f2f2f2;color:#191919;cursor:pointer;display:inline-block;padding:.75em 1.5em;text-align:center;margin:0 .75em 1.5em 0}button:hover{background:#d9d9d9;color:#000}button:not([disabled]){background:#f9c412;color:#181818;background:var(--primary)}button:not([disabled]):hover{background:#ba9005;color:#000;background:var(--primary-dark)}*{border:0;box-sizing:border-box}body,header nav a{font-family:var(--font-family)}body{background:#181818;color:#eee}header{padding:4.5em 1.5em 3em;width:37.5em;margin:0 auto;text-align:center;max-width:100%;display:flex;align-items:center;flex-direction:column}header p,ul{margin-top:0}header nav h1{float:left;font-size:inherit;line-height:inherit;margin:0;text-align:left}header nav a{font-weight:700;text-decoration:none;color:#181818;margin-left:1.5em}header nav a:first-of-type{margin-left:auto}header nav a:last-of-type{margin-right:1.5em}main{max-width:70rem;margin:0 auto;border-top:.5px solid #ccc}footer{background:rgba(0,0,0,.8);color:#fff;padding:3em;text-align:center}footer>*{margin:1.5em}footer nav a img{vertical-align:middle}footer nav,footer p{font-size:90%}article{max-width:100%;padding:1.5em;width:37.5em;margin:0 auto}li ul{margin-bottom:0}blockquote{border-left:1px solid #f9c412;padding:0 1.5em;margin:1.5em 0 1.5em 1.5em;border-left:1px solid var(--primary)}blockquote footer{background:0 0;display:block;color:#ccc;padding:.75em 0;font-size:90%;text-align:start}</style><header><nav><div id=nav><h1><a href=/ title=Homepage>Re Alvarez Parmar's Blog</a></h1><a href=/about/ >About</a></div><div id=reading-progress aria-hidden=true></div></nav><aside>5 min read.</aside><dialog id=message></dialog><noscript><img alt="" height=1 src="/api/ga?v=1&_v=j83&t=pageview&dr=https%3A%2F%2Fno-script.com&_s=1&dh=realvarez.com&dp=%2Fposts%2Febpf-speed-explained%2F&ul=en-us&de=UTF-8&dt=How%20is%20eBPF%20efficient%20for%20observability&tid=G-B5XRB3YVTR" style=display:none width=1></noscript></header><main><article><blockquote><p>Everybody says eBPF is fast, but how?</blockquote><p>The Berkeley Packet Filter (BPF or eBPF) is a virtual machine based on registers, initially designed for filtering network packets, best known for its use in <code>tcpdump</code>. In this post, we learn what is exactly that makes BPF so appealing for a number of use cases.<h2 id=introduction>Introduction <a href=#introduction class=direct-link>#</a></h2><p>BPF programs are small programs that run in the Linux kernel when events occur. You can think of BPF programs as event driven functions (like AWS Lambda). BPF has access to a subset of kernel functions and memory. It is designed to be safe, that is poor BPF code won’t crash your kernel.<p>In the containers world, BPF is increasingly becoming relevant. Its most popular use case is Cilium, which uses eBPF to provide a <a href=https://cilium.io/blog/2021/12/01/cilium-service-mesh-beta>“sidecarless” service mesh</a> and <a href=https://github.com/pixie-io/pixie>Pixie</a>, which uses eBPF to collect telemetry data.<p>Other popular BPF uses are:<ul><li><strong>Debugging and Tracing -</strong> trace any <code>syscall</code> or kernel function or any user space program.<ul><li><a href=https://github.com/iovisor/bpftrace>bpftrace</a> allows users to trace from the Linux command line.</ul><li><strong>Networking -</strong> Inspect, filter, manipulate traffic.<ul><li>User space program can attach a filter to any socket and inspect the traffic flowing through it. They can also allow, disallow, redirect packets.</ul><li><strong>Security monitoring and sandboxing</strong><ul><li>BPF programs can detect and report the <code>syscalls</code> occurring on a system.<li>BPF programs can prevent applications from performing certain <code>syscalls</code> on a system (e.g., prevent deleting a file).</ul></ul><p>Linux has allowed us to perform above functions for decades, but BPF helps us perform these tasks more efficiently. BPF programs use fewer CPU and memory resources than traditional solutions.<h2 id=how-is-bpf-faster%3F>How is BPF faster? <a href=#how-is-bpf-faster%3F class=direct-link>#</a></h2><p>BPF programs are faster because BPF code runs in kernel space.<p>Consider the steps a program has to take to calculate the number of bytes sent out on a Linux system. First, the kernel generates raw data as network activity occurs. This raw data packs a ton of information, most of which is irrelevant for calculating <em>bytes out</em> metrics. So, whatever is generating aggregated metrics will have to filter the relevant data points repeatedly and run mathematical calculations on them. This process is repeated hundreds of times (or more) every minute.<p>Since traditional monitoring programs run in user space, all that raw data that the kernel generates has to be copied from kernel space into user space. This data copy and filtering operation can be very taxing on the CPU. This is why ptrace is slow (whereas <a href=https://github.com/iovisor/bpftrace><code>bpftrace</code></a> is not).<p>eBPF avoids this copying of data from kernel space to user space. You can run a program in kernel space to aggregate the data you need and send just the output to user space.<p>Before BPF, large amounts of raw data from the kernel had to be copied over to user space for analysis. BPF allows creating histograms and filtering data within the kernel, which is much faster than exchanging massive amounts of data between user and kernel space.<h2 id=bpf-maps>BPF Maps <a href=#bpf-maps class=direct-link>#</a></h2><p>BPF uses <strong>BPF maps</strong> to allow bidirectional data exchange between user and kernel space. In Linux, maps are a generic storage type for sharing data between user and kernel space. They are key value stores that reside in the kernel.<p>For metrics generation, BPF programs run calculations in kernel space and write results to BPF maps that a userspace application can read (and also write to).<hr><p>Now you know why eBPF is efficient. It’s because BPF provides a way to run programs in kernel space and avoid copying irrelevant data between kernel and userspace.<h2 id=references>References <a href=#references class=direct-link>#</a></h2><p><a href=https://thenewstack.io/how-ebpf-streamlines-the-service-mesh>How eBPF Streamlines the Service Mesh</a><p><a href=https://buoyant.io/2022/06/07/ebpf-sidecars-and-the-future-of-the-service-mesh/ >eBPF, sidecars, and the future of the service mesh</a><p><a href=https://av.tib.eu/media/44349>TIB AV-Portal</a><p><a href=https://www.amazon.com/Linux-Observability-BPF-Programming-Performance/dp/1492050202>Linux Observability with BPF: Advanced Programming for Performance Analysis and Networking</a><hr><h2 id=appendix>Appendix <a href=#appendix class=direct-link>#</a></h2><p>Containers use Linux Namespaces, a feature of the Linux kernel that partitions kernel resources such that one set of processes sees one set of resources while another set of processes sees a different set of resources.<p>Under the hood, containers use <code>iptables</code> to network. Linux developers didn’t intend to run thousands of <code>iptables</code> rules on every node. To overcome the performance limitations in <code>iptables</code>, kernel devs are replacing <a href=https://cilium.io/blog/2018/04/17/why-is-the-kernel-community-replacing-iptables><code>iptables</code> with BPF</a>.<h2 id=bpf-verifier>BPF Verifier <a href=#bpf-verifier class=direct-link>#</a></h2><p>BPF allows anyone to run code in kernel space without being a kernel dev, compiling your own kernel, or writing custom kernel extensions that can hugely reduce the stability of the kernel.<p>BPF programs are safe. The <strong>BPF Verifier</strong> ensures code is safe to run in kernel. ← <strong>Explain this</strong><p>Linux kernel includes a JIT compiler for BPF instructions. Once verification completes, JIT transforms bytecode to machine code.<h2 id=bpf-programs>BPF programs <a href=#bpf-programs class=direct-link>#</a></h2><p>Written in a subset of C. LLVM compiles BPF programs into bytecode.<p><strong>BPF tracepoints</strong> are static marks in the kernel’s codebase that allow you to inject any code for tracing and debugging.<h2 id=ebpf-and-mtls>eBPF and mTLS <a href=#ebpf-and-mtls class=direct-link>#</a></h2><p>eBPF cannot do mTLS because it operates in kernel space entirely.<p>Proxy mTLS is handled by the sidecar, which runs in the user space.<h2 id=tcpdump-and-seccomp>tcpdump and Seccomp <a href=#tcpdump-and-seccomp class=direct-link>#</a></h2><p>Generate BPF bytecode.<p>tcpdump is frontend to <code>libpcap</code>. It reads packets from the NIC and writes to a file. PCAP filter on Linux are compiled to BPF programs. When you use <code>tcpdump</code> , you compile and load a BPF program to filter packets.<h2 id=kubectl-trace>kubectl trace <a href=#kubectl-trace class=direct-link>#</a></h2><p><a href="craftdocs://open?blockId=245EFFA2-BA97-4186-932A-F96888BF9F32&spaceId=9d54cc03-adfe-f72f-3389-565eb7356d1d"><strong>kubectl-trace</strong></a></p><share-widget><button aria-label=Share href=https://blog.realvarez.com/posts/ebpf-speed-explained/ on-click=share><div></div></button></share-widget><script type=application/ld+json>{
  "@context": "https://schema.org",
  "@type": "Article",
  "headline": "How is eBPF efficient for observability",
  "image": [],
  "author": "", 
  "genre": "Insert a schema.org genre", 
  "publisher": {
    "@type": "Organization",
    "name": "",
    "logo": {
      "@type": "ImageObject",
      "url": "/img/favicon/favicon-192x192.png?hash=ae2c3e88f6"
    }
  },
  "url": "https://blog.realvarez.com/posts/ebpf-speed-explained/",
  "mainEntityOfPage": "https://blog.realvarez.com/posts/ebpf-speed-explained/",
  "datePublished": "2022-07-09",
  "dateModified": "2023-04-09",
  "description": "Everybody says eBPF is fast, but how? The Berkeley Packet Filter (BPF or eBPF) is a virtual machine based on registers, initially designed..."
}</script><p>Published <time datetime=2022-07-09>09 Jul 2022</time></article></main><footer><a href=/about/ ></a></footer>